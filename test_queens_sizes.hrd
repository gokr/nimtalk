#!/usr/bin/env harding
# Test N-queens for various sizes

| Queens n result results i sum solver |

results := Array new.

n := 1.
[ n <= 4 ] whileTrue: [
  Queens := Object deriveWithAccessors: #(freeRows freeMaxs freeMins queenRows boardSize).
  
  Queens>>initialize: size [
    | j |
    self boardSize: size.
    self freeRows: (Array new: size).
    self freeMaxs: (Array new: (size + size)).
    self freeMins: (Array new: (size + size)).
    self queenRows: (Array new: size).
    
    j := 1.
    [ j <= size ] whileTrue: [
      self freeRows at: j put: 1.
      self queenRows at: j put: 0.
      j := j + 1
    ].
    
    j := 1.
    [ j <= (size + size) ] whileTrue: [
      self freeMaxs at: j put: 1.
      self freeMins at: j put: 1.
      j := j + 1
    ]
  ].
  
  Queens>>placeQueen: column [
    | row subResult rowFree maxIdx minIdx maxFree minFree isFree size offset j |
    size := self boardSize.
    offset := size.
    row := 1.
    [ row <= size ] whileTrue: [
      rowFree := self freeRows at: row.
      maxIdx := row + column.
      maxFree := self freeMaxs at: maxIdx.
      minIdx := row - column + offset.
      minFree := self freeMins at: minIdx.
      
      isFree := 0.
      rowFree = 1 ifTrue: [
        maxFree = 1 ifTrue: [
          minFree = 1 ifTrue: [
            isFree := 1
          ]
        ]
      ].
      
      isFree = 1 ifTrue: [
        self freeRows at: row put: 0.
        self freeMaxs at: maxIdx put: 0.
        self freeMins at: minIdx put: 0.
        self queenRows at: column put: row.
        
        column = size ifTrue: [
          ^ 1
        ] ifFalse: [
          subResult := self placeQueen: (column + 1).
          subResult = 1 ifTrue: [
            ^ 1
          ]
        ].
        
        self freeRows at: row put: 1.
        self freeMaxs at: maxIdx put: 1.
        self freeMins at: minIdx put: 1.
        self queenRows at: column put: 0
      ].
      row := row + 1
    ].
    ^ 0
  ].
  
  solver := Queens new.
  solver initialize: n.
  result := solver placeQueen: 1.
  results add: result.
  
  n := n + 1
].

sum := 0.
i := 1.
[ i <= results size ] whileTrue: [
  sum := sum + (results at: i).
  i := i + 1
].

sum
