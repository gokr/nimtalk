#!/usr/bin/env harding
#
# SortedCollection.hrd - Collection that maintains sorted order
# Uses composition with an internal Array, not inheritance
#

SortedCollection := Object derive: #(sortBlock elements).

SortedCollection class>>new [
    | sc |
    sc := self basicNew.
    sc setSortBlock: [:a :b | a < b].
    sc initElements.
    ^sc
]

SortedCollection class>>new: items sortBlock: aBlock [
    | sc |
    sc := self basicNew.
    sc setSortBlock: aBlock.
    sc initElements.
    items do: [:item | sc add: item].
    ^sc
]

SortedCollection class>>sortBlock: aBlock [
    ^self new: #() sortBlock: aBlock
]

SortedCollection>>initElements [
    elements := Array new.
]

SortedCollection>>setSortBlock: aBlock [
    sortBlock := aBlock.
]

SortedCollection>>sortBlock [
    ^sortBlock
]

SortedCollection>>sortBlock: aBlock [
    sortBlock := aBlock.
    self resort.
]

SortedCollection>>add: anObject [
    # Add in sorted position using binary search for efficiency
    | insertIndex low high mid |
    self size = 0 ifTrue: [
        elements add: anObject.
        ^anObject
    ].

    # Binary search for insertion point
    low := 1.
    high := self size.
    insertIndex := high + 1.  # Default to end

    [ low <= high ] whileTrue: [
        mid := (low + high) // 2.
        (sortBlock value: (self at: mid) value: anObject)
            ifTrue: [ low := mid + 1 ]
            ifFalse: [
                insertIndex := mid.
                high := mid - 1.
            ].
    ].

    # Insert at insertIndex (1-based)
    self insert: anObject at: insertIndex.
    ^anObject
]

SortedCollection>>insert: anObject at: index [
    # Insert object at specific index, shifting elements
    | i idx |
    i := self size.
    elements add: nil.  # Expand array by 1
    idx := index.
    [ i >= idx ] whileTrue: [
        self at: (i + 1) put: (self at: i).
        i := i - 1.
    ].
    self at: idx put: anObject.
    ^anObject
]

SortedCollection>>size [
    ^elements size
]

SortedCollection>>at: index [
    ^elements at: index
]

SortedCollection>>at: index put: value [
    elements at: index put: value.
    ^value
]

SortedCollection>>do: aBlock [
    elements do: aBlock.
    ^self
]

SortedCollection>>resort [
    # Re-sort all elements after sortBlock change
    | sorted |
    sorted := elements sorted: sortBlock.
    self removeAll.
    sorted do: [:item | elements add: item].
    ^self
]

SortedCollection>>removeAll [
    elements removeAll.
    ^self
]

SortedCollection>>removeAt: index [
    ^elements removeAt: index
]

SortedCollection>>includes: anObject [
    # Use binary search for O(log n) lookup
    ^(self find: anObject) notNil
]

SortedCollection>>find: anObject [
    # Binary search for object, return it if found, nil otherwise
    | low high mid |
    low := 1.
    high := self size.

    [ low <= high ] whileTrue: [
        mid := (low + high) // 2.
        (self at: mid) = anObject ifTrue: [ ^self at: mid ].
        (sortBlock value: (self at: mid) value: anObject)
            ifTrue: [ low := mid + 1 ]
            ifFalse: [ high := mid - 1 ].
    ].
    ^nil
]

SortedCollection>>remove: anObject [
    # Remove first occurrence of anObject
    | index |
    index := self indexOf: anObject.
    index notNil ifTrue: [ self removeAt: index ].
    ^anObject
]

SortedCollection>>indexOf: anObject [
    # Binary search for index of object
    | low high mid |
    low := 1.
    high := self size.

    [ low <= high ] whileTrue: [
        mid := (low + high) // 2.
        (self at: mid) = anObject ifTrue: [ ^mid ].
        (sortBlock value: (self at: mid) value: anObject)
            ifTrue: [ low := mid + 1 ]
            ifFalse: [ high := mid - 1 ].
    ].
    ^nil
]

SortedCollection>>first [
    # Smallest element (at index 1)
    ^self at: 1
]

SortedCollection>>last [
    # Largest element (at end)
    ^self at: (self size)
]

SortedCollection>>select: aBlock [
    # Return new SortedCollection with elements satisfying aBlock
    | result |
    result := SortedCollection new.
    self do: [:each | (aBlock value: each) ifTrue: [ result add: each ]].
    ^result
]

SortedCollection>>reject: aBlock [
    # Return new SortedCollection with elements not satisfying aBlock
    ^self select: [:each | (aBlock value: each) not]
]

SortedCollection>>collect: aBlock [
    # Transform each element, return Array
    ^elements collect: aBlock
]

SortedCollection>>copy [
    # Return copy with same sortBlock
    | copy |
    copy := SortedCollection new: #() sortBlock: sortBlock.
    self do: [:item | copy add: item].
    ^copy
]

SortedCollection>>asSortedCollection [
    ^self
]

SortedCollection>>asArray [
    # Return a copy of the elements as Array
    | result |
    result := Array new.
    self do: [:item | result add: item].
    ^result
]

SortedCollection>>printString [
    # Return string representation showing elements
    ^elements printString
]

Array>>asSortedCollection [
    ^SortedCollection new: self sortBlock: [:a :b | a < b]
]

Array>>asSortedCollection: aBlock [
    ^SortedCollection new: self sortBlock: aBlock
]
