#!/usr/bin/env nemo
#
# Object.nt - Root object with core methods
# This is the foundation of the Nemo object system

# Object is the root of the class hierarchy
# It provides fundamental behaviors that all objects inherit

# Note: Object is set by initGlobals() in interpreter/evaluator.nim
#====================================================================
# Object creation and copying
#====================================================================

# Note: derive, derive:, and new are defined as class methods in initCoreClasses
# They are installed as native methods on the Object class and create proper
# Class-based objects with slot accessors.
#
# Object class>>derive - Create a subclass with no slots
# Object class>>derive: - Create a subclass with declared instance variables
# Object class>>new - Create a new instance of the class
#
# Usage: Point := Object derive: #(x y).
#        point := Point new.
#        point x: 10.

Object>>clone <primitive primitiveClone>

#====================================================================
# Class-side methods (using class>> syntax)
#====================================================================

Object class>>derive: ivarArray methods: methodBlock [
  # Create a subclass with instance variables AND define methods in one expression.
  # Usage: Person := Object derive: #(name age) methods: [
  #   self >> greet [ "Hello, I am " + name ]
  #   self >> haveBirthday [ age := age + 1 ]
  # ]
  | newClass |
  newClass := self derive: ivarArray.
  newClass extend: methodBlock.
  ^ newClass
]

Object class>>derive: slotArray superclasses: superclassArray methods: methodBlock [
  # Create a subclass with instance variables, additional superclasses and define methods in one expression.
  # The receiver class determines the instance type (Integer, Float, String, Array, Table, etc.).
  # Other superclasses must be compatible (usually Mixin subclasses with only methods, no conflicting slots).
  #
  # Note: Methods are applied BEFORE adding superclasses, so you can override conflicting methods
  # from superclasses. If methods conflict and are not overridden, an error will be raised.
  #
  # Usage:
  #   Child := Object derive: #(x) superclasses: #(Parent1 Parent2) methods: [
  #     self >> bar [ 42 ]
  #   ]
  #
  # Or create a mixin class:
  #   Mixin1 := Object derive: #() superclasses: #() methods: [
  #     self >> foo [ 1 ]
  #   ]
  #
  #   Mixin2 := Object derive: #() superclasses: #() methods: [
  #     self >> bar [ 2 ]
  #   ]
  #
  #   Combined := Object derive: #() superclasses: #(Mixin1 Mixin2) methods: [
  #     self >> both [ self foo + self bar ]
  #   ]
  #
  | newClass |
  # First create the class with slots (deriving from self as first superclass)
  newClass := self derive: slotArray.

  # Apply methods FIRST - this allows overrides to resolve conflicts before adding superclasses
  newClass extend: methodBlock.

  # Then add each additional superclass (this performs conflict detection)
  superclassArray do: [:superclass |
    newClass addSuperclass: superclass
  ].

  ^ newClass
]

Object>>printHierarchy [
  # Print an indented class hierarchy with slots as Nemo code
  self printHierarchyIndent: 0
]

Object>>printHierarchyIndent: level [
  # Print this class and its superclasses recursively with indentation
  # Usage: MyClass printHierarchyIndent: 0  # Start with 0 indentation
  self printClassIndent: level.

  # Recursively print superclasses with increased indentation
  self superclassNames do: [:superclassName |
    | superclass |
    superclass := Global at: superclassName ifAbsent: [ nil ].
    superclass isNil ifFalse: [
      superclass printHierarchyIndent: (level + 1)
    ]
  ]
]

Object>>printClassIndent: level [
  # Print this class definition with indentation
  | indent slotsString |
  indent := "    " repeat: level

  # Build slots part
  slotsString := self slotNames isNil
    ifTrue: [ "#()" ]
    ifFalse: [
      self slotNames size = 0
        ifTrue: [ "#()" ]
        ifFalse: [
          "#(" , ((self slotNames collect: [:name | name asString]) join: ", ") , ")"
        ]
    ]

  # Build superclasses part
  self superclassNames isNil
    ifTrue: [ slotsString println ]
    ifFalse: [
      self superclassNames size = 0
        ifTrue: [ slotsString println ]
        ifFalse: [
          (slotsString , " superclasses: #(" , (self superclassNames join: ", ") , ")") println
        ]
    ]
]

#====================================================================
# Property access
#====================================================================

Object>>at: key <primitive primitiveAt: key>

Object>>at: key put: value <primitive primitiveAt: key put: value>

Object>>hasProperty: key <primitive primitiveHasProperty: key>

Object>>properties <primitive primitiveProperties>

#====================================================================
# Class reflection
#====================================================================

Object>>slotNames <primitive primitiveSlotNames>

Object>>superclassNames <primitive primitiveSuperclassNames>


#====================================================================
# Method management
#====================================================================

Object>>respondsTo: selector <primitive primitiveRespondsTo: selector>

Object>>methods <primitive primitiveMethods>

Object>>doesNotUnderstand: selector with: arg1 with: arg2 [
  # Default handler for unrecognized messages.
  # Subclasses can override to provide custom behavior.
  # selector: the message selector that was not understood
  # arg1, arg2: optional arguments that were passed with the message
  self error: ("Message not understood: " , (selector asString))
]

#====================================================================
# Identity and comparison
#====================================================================

Object>>= other [
  # Test if this object equals other (value equality).
  # Default implementation uses identity (==).
  # Subclasses like String, Number should override for value comparison.
  ^ self == other
]

Object>>== other <primitive primitiveEquals: other>

Object>>printString [
  # Return a string representation of this object.
  ^ "<" , self class name , ">"
]

Object>>className <primitive primitiveClassName>

Object>>class <primitive primitiveClass>

#====================================================================
# Error handling
#====================================================================

Object>>error: message <primitive primitiveError: message>

#====================================================================
# Testing and debugging
#====================================================================

Object>>inspect [
  # Open an inspector on this object. (placeholder)
  self printString print
]

Object>>yourself [
  # Return self - useful for cascading messages.
  ^ self
]

#====================================================================
# Initialization
#====================================================================

Object>>initialize [
  # Initialize a new instance. Subclasses should override.
  ^ self
]

#====================================================================
# Utility methods
#====================================================================

Object>>isNil [
  # Check if object is nil
  ^ self = nil
]

Object>>notNil [
  # Check if object is not nil
  ^ self isNil not
]

Object>>isKindOf: aClass <primitive primitiveIsKindOf: aClass>

Object>>asString [
  # Return string representation
  ^ self printString
]

Object>>asSelfDo: aBlock <primitive primitiveAsSelfDo: aBlock>

Object class>>extend: aBlock [
  # Extend this class with instance methods defined in aBlock.
  # The block is evaluated with self bound to this object.
  # Usage: Person extend: [
  #   self >> greet [ "Hello!" println ]
  #   self >> name: n [ name := n ]
  # ]
  ^ self asSelfDo: aBlock
]

Object class>>extendClass: aBlock [
  # Extend the class-side (metaclass) with methods defined in aBlock.
  # These are methods on the class object itself, not instances.
  # Usage: Person extendClass: [
  #   self >> newNamed: name [ ... create and return instance ... ]
  #   self >> withName: name age: age [ ... factory method ... ]
  # ]
  ^ self asSelfDo: aBlock
]

Object class>>name <primitive primitiveClassName>

Object>>print [
  # Print to stdout without newline
  Stdout write: self printString
]

Object>>println [
  # Print to stdout with newline
  Stdout writeline: self printString
]

#====================================================================
# Comparison
#====================================================================

Object>>~= other [
  # Not equal - delegates to = and negates
  ^ (self = other) not
]

Object>>== other <primitive primitiveEquals: other>

Object>>~~ other [
  # Not identity - true if different objects
  ^ (self == other) not
]
