#!/usr/bin/env nemo
#
# Object.nt - Root object with core methods
# This is the foundation of the Nemo object system

# Object is the root of the class hierarchy
# It provides fundamental behaviors that all objects inherit

# Note: Object is set by initGlobals() in interpreter/evaluator.nim
#====================================================================
# Object creation and copying
#====================================================================

# Note: derive, derive:, and new are defined as class methods in initCoreClasses
# They are installed as native methods on the Object class and create proper
# Class-based objects with slot accessors.
#
# Object class>>derive - Create a subclass with no slots
# Object class>>derive: - Create a subclass with declared instance variables
# Object class>>new - Create a new instance of the class
#
# Usage: Point := Object derive: #(x y).
#        point := Point new.
#        point x: 10.

Object>>clone [
  # Create a shallow copy of this object without class/superclass links.
  # The copy has no parents and shares property/method dictionaries.
  ^ self perform: #primitiveClone
]

#====================================================================
# Class-side methods (using class>> syntax)
#====================================================================

Object class>>derive: ivarArray methods: methodBlock [
  # Create a subclass with instance variables AND define methods in one expression.
  # Usage: Person := Object derive: #(name age) methods: [
  #   self >> greet [ "Hello, I am " + name ]
  #   self >> haveBirthday [ age := age + 1 ]
  # ]
  | newClass |
  newClass := self derive: ivarArray.
  newClass extend: methodBlock.
  ^ newClass
]

Object class>>derive: slotArray parents: parentsArray methods: methodBlock [
  # Create a subclass with instance variables, additional parents and define methods in one expression.
  # The receiver class determines the instance type (Integer, Float, String, Array, Table, etc.).
  # Other parents must be compatible (usually Mixin subclasses with only methods, no conflicting slots).
]

Object class>>derive: parentsArray methods: methodBlock [
  # Simplified form: derive from multiple parents with no new slots.
  # The first parent determines the instance type.
  ^ self derive: parentsArray ivarArray: #() methods: methodBlock
]

#====================================================================
# Property access
#====================================================================

Object>>at: key [
  # Get the value of a property. Searches the object and its class hierarchy.
  ^ self perform: #primitiveAt: with: key
]

Object>>at: key put: value [
  # Set a property value on this object (not on parent class).
  ^ self perform: #primitiveAt:put: with: key with: value
]

Object>>hasProperty: key [
  # Check if this object directly has a property (not in parents).
  ^ self perform: #primitiveHasProperty: with: key
]

Object>>properties [
  # Return a collection of all property keys on this object.
  ^ self perform: #primitiveProperties
]

#====================================================================
# Method management
#====================================================================

Object>>respondsTo: selector [
  # Check if this object or its class hierarchy responds to a message.
  ^ self perform: #primitiveRespondsTo: with: selector
]

Object>>methods [
  # Return a collection of all method selectors on this object.
  ^ self perform: #primitiveMethods
]

Object>>doesNotUnderstand: selector with: arg1 with: arg2 [
  # Default handler for unrecognized messages.
  # Subclasses can override to provide custom behavior.
  # selector: the message selector that was not understood
  # arg1, arg2: optional arguments that were passed with the message
  self error: ("Message not understood: " , (selector asString))
]

#====================================================================
# Identity and comparison
#====================================================================

Object>>= other [
  # Test if this object equals other (value equality).
  # Default implementation uses identity (==).
  # Subclasses like String, Number should override for value comparison.
  ^ self == other
]

Object>>== other [
  # Test if this object is the same object as other (identity).
  ^ self perform: #primitiveEquals: with: other
]

Object>>printString [
  # Return a string representation of this object.
  ^ "<" , self className , ">"
]

Object>>className [
  # Return the class name of this object.
  | tags |
  tags := self at: "tags"
  tags isNil
    ifTrue: [ ^ "Object" ]
    ifFalse: [ ^ tags first ]
]

#====================================================================
# Error handling
#====================================================================

Object>>error: message [
  # Signal an error with the given message.
  self perform: #primitiveError: with: message
]

#====================================================================
# Testing and debugging
#====================================================================

Object>>inspect [
  # Open an inspector on this object. (placeholder)
  self printString print
]

Object>>yourself [
  # Return self - useful for cascading messages.
  ^ self
]

#====================================================================
# Initialization
#====================================================================

Object>>initialize [
  # Initialize a new instance. Subclasses should override.
  ^ self
]

#====================================================================
# Utility methods
#====================================================================

Object>>isNil [
  # Check if object is nil
  ^ self = nil
]

Object>>notNil [
  # Check if object is not nil
  ^ self isNil not
]

Object>>class [
  # Return the class of this object
  | tags |
  tags := self at: "tags"
  tags isNil ifTrue: [ ^ Object ]
  ^ Global at: (tags first) ifAbsent: [ Object ]
]

Object>>isKindOf: aClass [
  # Check if object is kind of aClass (in class hierarchy)
  ^ self perform: #primitiveIsKindOf: with: aClass
]

Object>>asString [
  # Return string representation
  ^ self printString
]

Object>>asSelfDo: aBlock [
  # Evaluate aBlock with self temporarily bound to this object.
  # This allows executing code in the context of any object.
  # Usage: someObject asSelfDo: [ self doSomething ]
  ^ self perform: #primitiveAsSelfDo: with: aBlock
]

Object>>extend: aBlock [
  # Extend this object with instance methods defined in aBlock.
  # The block is evaluated with self bound to this object.
  # Usage: Person extend: [
  #   self >> greet [ "Hello!" println ]
  #   self >> name: n [ name := n ]
  # ]
  ^ self asSelfDo: aBlock
]

Object>>extendClass: aBlock [
  # Extend the class-side (metaclass) with methods defined in aBlock.
  # These are methods on the class object itself, not instances.
  # Usage: Person extendClass: [
  #   self >> newNamed: name [ ... create and return instance ... ]
  #   self >> withName: name age: age [ ... factory method ... ]
  # ]
  # For now, this is equivalent to extend: since in the class model
  # the class IS the factory object. Methods added here are factory methods.
  ^ self asSelfDo: aBlock
]

Object>>print [
  # Print to stdout without newline
  Stdout write: self printString
]

Object>>println [
  # Print to stdout with newline
  Stdout writeline: self printString
]

#====================================================================
# Comparison
#====================================================================

Object>>~= other [
  # Not equal - delegates to = and negates
  ^ (self = other) not
]

Object>>== other [
  # Identity comparison - true if same object
  ^ self perform: #primitiveIdentity: with: other
]

Object>>~~ other [
  # Not identity - true if different objects
  ^ (self == other) not
]
