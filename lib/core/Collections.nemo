#!/usr/bin/env nemo
#
# Collections.nt - Collection protocols and behaviors
#

#====================================================================
# Array (seq) extensions
#====================================================================

Array>>do: block [
  # Iterate over each element, evaluating the block.
  | index size |
  index := 1
  size := self size
  [ index <= size ] whileTrue: [
    block value: (self at: index)
    index := index + 1
  ]
  ^ self
]

# Native Array methods (defined in objects.nim):
# add:, size, removeAt:, includes:, reverse, join:, sort, sorted
# These are registered directly on the Array class

Array>>isEmpty [
  # Check if array has no elements.
  ^ self size = 0
]

Array>>notEmpty [
  # Check if array has elements.
  ^ self size > 0
]

Array>>first [
  # Return first element.
  ^ self at: 1
]

Array>>last [
  # Return last element.
  ^ self at: (self size)
]

#====================================================================
# High-order collection methods
#====================================================================

Array>>collect: block [
  # Transform each element with the block, return new array.
  | result |
  result := Array new
  self do: [ :each | result add: (block value: each) ]
  ^ result
]

Array>>select: block [
  # Return new array with elements where block returns true.
  | result |
  result := Array new
  self do: [ :each |
    (block value: each) ifTrue: [ result add: each ]
  ]
  ^ result
]

Array>>reject: block [
  # Return new array with elements where block returns false.
  | result |
  result := Array new
  self do: [ :each |
    (block value: each) ifFalse: [ result add: each ]
  ]
  ^ result
]

Array>>detect: block [
  # Find first element where block returns true.
  self do: [ :each |
    (block value: each) ifTrue: [ ^ each ]
  ]
  ^ nil
]

Array>>detect: block ifNone: noneBlock [
  # Find first element where block returns true, or evaluate noneBlock.
  self do: [ :each |
    (block value: each) ifTrue: [ ^ each ]
  ]
  ^ noneBlock value
]

Array>>inject: initialValue into: block [
  # Accumulate a result by iterating with block.
  | result |
  result := initialValue
  self do: [ :each |
    result := block value: result value: each
  ]
  ^ result
]

Array>>anySatisfy: block [
  # Return true if any element satisfies the block.
  self do: [ :each |
    (block value: each) ifTrue: [ ^ true ]
  ]
  ^ false
]

Array>>allSatisfy: block [
  # Return true if all elements satisfy the block.
  self do: [ :each |
    (block value: each) ifFalse: [ ^ false ]
  ]
  ^ true
]

Array>>withIndexDo: block [
  # Iterate over each element with its 1-based index, evaluating the block.
  | index size |
  index := 1
  size := self size
  [ index <= size ] whileTrue: [
    block value: (self at: index) value: index
    index := index + 1
  ]
  ^ self
]

Array>>copyFrom: start to: end [
  # Return new array with elements from start to end (inclusive, 1-based).
  | result index |
  result := Array new
  index := start
  [ index <= end ] whileTrue: [
    result add: (self at: index)
    index := index + 1
  ]
  ^ result
]

Array>>with: otherArray do: block [
  # Iterate over two collections in parallel, evaluating block with elements from both.
  | index size |
  index := 1
  size := self size
  (size = otherArray size) ifFalse: [ self error: "Collections must be same size for with:do:" ]
  [ index <= size ] whileTrue: [
    block value: (self at: index) value: (otherArray at: index)
    index := index + 1
  ]
  ^ self
]

Array>>addFirst: element [
  # Add element to beginning of array (requires shifting existing elements).
  # Note: This is O(n) operation. For frequent front insertions, consider different structure.
  | newArray |
  newArray := Array new
  newArray add: element
  self do: [ :each | newArray add: each ]
  # Copy elements back
  self removeAll
  newArray do: [ :each | self add: each ]
  ^ element
]

Array>>addLast: element [
  # Add element to end of array (same as add:).
  ^ self add: element
]

Array>>removeFirst [
  # Remove and return first element.
  | first |
  first := self first
  self removeAt: 0
  ^ first
]

Array>>removeLast [
  # Remove and return last element.
  | last index |
  index := self size
  last := self at: index
  self removeAt: index
  ^ last
]

Array>>addAll: collection [
  # Add all elements from collection to this array.
  collection do: [ :each | self add: each ]
  ^ collection
]

Array>>removeAll [
  # Remove all elements from array.
  [ self isEmpty ] whileFalse: [ self removeAt: 0 ]
  ^ self
]

Table>>printString [
  # Return a string representation showing key-value pairs.
  # Uses Smalltalk-style arrow syntax with dot separators: #{key -> value . ...}
  | result isFirst |
  result := "#{".
  isFirst := true.
  self keys do: [ :key |
    isFirst ifTrue: [ isFirst := false ] ifFalse: [ result := result , " . " ].
    result := result , (key printString) , " -> " , ((self at: key) printString)
  ].
  ^ result , "}"
]

#====================================================================
# Table (Dictionary) extensions
#====================================================================

Table>>do: block [
  # Iterate over key-value pairs.
  self keys do: [ :key |
    block value: key value: (self at: key)
  ]
  ^ self
]

# Native Table methods (defined in objects.nim):
# keys, includesKey:, removeKey:
# These are registered directly on the Table class

Table>>values [
  # Return array of all values.
  | result |
  result := Array new
  self keys do: [ :key | result add: (self at: key) ]
  ^ result
]

Table>>size [
  # Return number of key-value pairs.
  ^ self keys size
]

Table>>isEmpty [
  # Check if table has no entries.
  ^ self size = 0
]

Table>>notEmpty [
  # Check if table has entries.
  ^ self size > 0
]

Table>>keysAndValuesDo: block [
  # Iterate over all key-value pairs.
  self keys do: [ :key |
    block value: key value: (self at: key)
  ]
]

Table>>at: key ifAbsent: block [
  # Get value at key, or evaluate block if key not present.
  (self includesKey: key) ifTrue: [ ^ self at: key ] ifFalse: [ ^ block value ]
]

Table>>at: key ifAbsentPut: block [
  # Get value at key, or put result of block and return it.
  | value |
  (self includesKey: key) ifTrue: [ ^ self at: key ]
  value := block value
  self at: key put: value
  ^ value
]

Table>>at: key ifPresent: presentBlock [
  # If key present, evaluate presentBlock with value, else return nil.
  (self includesKey: key) ifTrue: [ ^ presentBlock value: (self at: key) ]
  ^ nil
]

Table>>at: key ifPresent: presentBlock ifAbsent: absentBlock [
  # If key present, evaluate presentBlock with value, else evaluate absentBlock.
  (self includesKey: key) ifTrue: [ ^ presentBlock value: (self at: key) ]
  ^ absentBlock value
]

#====================================================================
# Set (using HashSet)
#====================================================================

Set := Object derive

Set>>new [
  # Create new empty set.
  ^ self perform: #primitiveSetNew
]

Set>>add: element [
  # Add element to set.
  ^ self perform: #primitiveSetAdd: with: element
]

Set>>remove: element [
  # Remove element from set.
  ^ self perform: #primitiveSetRemove: with: element
]

Set>>includes: element [
  # Check if set includes element.
  ^ self perform: #primitiveSetIncludes: with: element
]

Set>>size [
  # Return number of elements.
  ^ self perform: #primitiveSetSize
]

Set>>isEmpty [
  # Check if set is empty.
  ^ self size = 0
]

Set>>union: otherSet [
  # Return union of self and otherSet.
  ^ self perform: #primitiveSetUnion: with: otherSet
]

Set>>intersection: otherSet [
  # Return intersection of self and otherSet.
  ^ self perform: #primitiveSetIntersection: with: otherSet
]

Set>>difference: otherSet [
  # Return difference (self - otherSet).
  ^ self perform: #primitiveSetDifference: with: otherSet
]

Set>>do: block [
  # Iterate over all elements.
  ^ self perform: #primitiveSetDo: with: block
]

#====================================================================
# Collection creation - class methods
#====================================================================

Array>>new [
  # Create new empty array.
  ^ Array new: 0
]

# Note: Array new: and Table new are implemented as native class methods in objects.nim
# The primitives are registered directly on the classes
