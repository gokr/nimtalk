#!/usr/bin/env harding
#
# Number.nt - Extensions to Number class hierarchy
# Adds Smalltalk-style numeric operations to existing Integer and Float classes
#
# Note: Number, Integer, and Float classes are defined in the interpreter.
# This file extends them with additional methods using >> syntax.
#

#====================================================================
# Number class extensions
#====================================================================

Number >> max: other [
  self > other
    ifTrue: [ ^ self ]
    ifFalse: [ ^ other ]
].

Number >> min: other [
  self < other
    ifTrue: [ ^ self ]
    ifFalse: [ ^ other ]
].

Number >> between: min and: max [
  (self >= min) ifFalse: [ ^ false ].
  (self <= max) ifFalse: [ ^ false ].
  ^ true
].

Number >> isZero [
  ^ self = 0
].

Number >> isPositive [
  ^ self > 0
].

Number >> isNegative [
  ^ self < 0
].

Number >> sign [
  self < 0 ifTrue: [ ^ 0 - 1 ].
  self > 0 ifTrue: [ ^ 1 ].
  ^ 0
].

Number >> asString [
  ^ self printString
].

Number >> squared [
  ^ self * self
].

#====================================================================
# Integer class extensions
#====================================================================

Integer >> abs [
  self < 0
    ifTrue: [ ^ 0 - self ].
  ^ self
].

Integer >> negated [
  ^ 0 - self
].

Integer >> even [
  ^ (self \\ 2) = 0
].

Integer >> odd [
  ^ (self \\ 2) <> 0
].

Integer >> to: end do: block [
  | i |
  i := self.
  [ i <= end ] whileTrue: [
    block value: i.
    i := i + 1
  ]
].

Integer >> to: end by: step do: block [
  | i |
  i := self.
  step > 0
    ifTrue: [
      [ i <= end ] whileTrue: [
        block value: i.
        i := i + step
      ]
    ]
    ifFalse: [
      [ i >= end ] whileTrue: [
        block value: i.
        i := i + step
      ]
    ]
].

Integer >> timesRepeat: block [
  | count |
  count := self.
  [ count > 0 ] whileTrue: [
    block value.
    count := count - 1
  ]
].

Integer >> factorial [
  self <= 1 ifTrue: [ ^ 1 ].
  ^ self * (self - 1) factorial
].

Integer >> gcd: other [
  | a b |
  a := self abs.
  b := other abs.
  [ b > 0 ] whileTrue: [
    | temp |
    temp := b.
    b := a \\ b.
    a := temp
  ].
  ^ a
].

Integer >> lcm: other [
  | gcd |
  gcd := self gcd: other.
  gcd = 0 ifTrue: [ ^ 0 ].
  ^ (self * other) abs // gcd
].

Integer >> to: end [
  # Create Interval from self to end
  ^ Interval from: self to: end
].

Integer >> to: end by: step [
  # Create Interval from self to end with step
  ^ Interval from: self to: end by: step
].

#====================================================================
# Float class extensions
#====================================================================

Float >> abs [
  self < 0.0
    ifTrue: [ ^ 0.0 - self ].
  ^ self
].

Float >> negated [
  ^ 0.0 - self
].
