#!/usr/bin/env harding
#
# Collections.nt - Collection protocols and behaviors
#

#====================================================================
# Array (seq) extensions
#====================================================================

Array>>do: block [
  # Iterate over each element, evaluating the block.
  | index size |
  index := 1
  size := self size
  [ index <= size ] whileTrue: [
    block value: (self at: index)
    index := index + 1
  ]
  ^ self
]

# Native Array methods (defined in objects.nim):
# add:, size, removeAt:, includes:, reverse, join:, sort, sorted
# These are registered directly on the Array class

Array>>isEmpty [
  # Check if array has no elements.
  ^ self size = 0
]

Array>>notEmpty [
  # Check if array has elements.
  ^ self size > 0
]

Array>>first [
  # Return first element.
  ^ self at: 1
]

Array>>last [
  # Return last element.
  ^ self at: (self size)
]

#====================================================================
# High-order collection methods
#====================================================================

Array>>collect: block [
  # Transform each element with the block, return new array.
  | result |
  result := Array new
  self do: [ :each | result add: (block value: each) ]
  ^ result
]

Array>>select: block [
  # Return new array with elements where block returns true.
  | result |
  result := Array new
  self do: [ :each |
    (block value: each) ifTrue: [ result add: each ]
  ]
  ^ result
]

Array>>reject: block [
  # Return new array with elements where block returns false.
  | result |
  result := Array new
  self do: [ :each |
    (block value: each) ifFalse: [ result add: each ]
  ]
  ^ result
]

Array>>detect: block [
  # Find first element where block returns true.
  self do: [ :each |
    (block value: each) ifTrue: [ ^ each ]
  ]
  ^ nil
]

Array>>inject: initialValue into: block [
  # Accumulate a result by iterating with block.
  | result |
  result := initialValue
  self do: [ :each |
    result := block value: result value: each
  ]
  ^ result
]

Array>>anySatisfy: block [
  # Return true if any element satisfies the block.
  self do: [ :each |
    (block value: each) ifTrue: [ ^ true ]
  ]
  ^ false
]

Array>>allSatisfy: block [
  # Return true if all elements satisfy the block.
  self do: [ :each |
    (block value: each) ifFalse: [ ^ false ]
  ]
  ^ true
]

Array>>withIndexDo: block [
  # Iterate over each element with its 1-based index, evaluating the block.
  | index size |
  index := 1
  size := self size
  [ index <= size ] whileTrue: [
    block value: (self at: index) value: index
    index := index + 1
  ]
  ^ self
]

Array>>copyFrom: start to: end [
  # Return new array with elements from start to end (inclusive, 1-based).
  | result index |
  result := Array new
  index := start
  [ index <= end ] whileTrue: [
    result add: (self at: index)
    index := index + 1
  ]
  ^ result
]

Array>>with: otherArray do: block [
  # Iterate over two collections in parallel, evaluating block with elements from both.
  | index size |
  index := 1
  size := self size
  (size = otherArray size) ifFalse: [ self error: "Collections must be same size for with:do:" ]
  [ index <= size ] whileTrue: [
    block value: (self at: index) value: (otherArray at: index)
    index := index + 1
  ]
  ^ self
]

Array>>addFirst: element [
  # Add element to beginning of array (requires shifting existing elements).
  # Note: This is O(n) operation. For frequent front insertions, consider different structure.
  | newArray |
  newArray := Array new
  newArray add: element
  self do: [ :each | newArray add: each ]
  # Copy elements back
  self removeAll
  newArray do: [ :each | self add: each ]
  ^ element
]

Array>>addLast: element [
  # Add element to end of array (same as add:).
  ^ self add: element
]

Array>>removeFirst [
  # Remove and return first element.
  | first |
  first := self first.
  self removeAt: 1.  # 1-based indexing for Harding arrays
  ^ first
]

Array>>removeLast [
  # Remove and return last element.
  | last index |
  index := self size.
  last := self at: index.
  self removeAt: index.
  ^ last
]

Array>>remove: anObject [
  # Remove first occurrence of anObject, return it if found, nil if not.
  ^ self remove: anObject ifAbsent: [ nil ]
]

Array>>remove: anObject ifAbsent: absentBlock [
  # Remove first occurrence of anObject, evaluate absentBlock if not found.
  | index |
  index := self indexOf: anObject.
  index notNil ifTrue: [
    # removeAt: uses 0-based indexing, but indexOf: returns 1-based
    self removeAt: (index - 1).
    ^ anObject
  ].
  ^ absentBlock value
]

Array>>indexOf: anObject [
  # Return 1-based index of first occurrence, nil if not found.
  | index size |
  index := 1.
  size := self size.
  [ index <= size ] whileTrue: [
    (self at: index) = anObject ifTrue: [ ^ index ].
    index := index + 1
  ].
  ^ nil
]

Array>>indexOf: anObject ifAbsent: absentBlock [
  # Return 1-based index, or evaluate absentBlock if not found.
  | index |
  index := self indexOf: anObject.
  index notNil ifTrue: [ ^ index ].
  ^ absentBlock value
]

Array>>addAll: collection [
  # Add all elements from collection to this array.
  collection do: [ :each | self add: each ]
  ^ collection
]

Array>>removeAll [
  # Remove all elements from array.
  [ self isEmpty ] whileFalse: [ self removeAt: 0 ]
  ^ self
]

Table>>printString [
  # Return a string representation showing key-value pairs.
  # Uses Smalltalk-style arrow syntax with dot separators: #{key -> value . ...}
  | result isFirst |
  result := "#{".
  isFirst := true.
  self keys do: [ :key |
    isFirst ifTrue: [ isFirst := false ] ifFalse: [ result := result , " . " ].
    result := result , (key printString) , " -> " , ((self at: key) printString)
  ].
  ^ result , "}"
]

#====================================================================
# Table (Dictionary) extensions
#====================================================================

Table>>do: block [
  # Iterate over key-value pairs.
  self keys do: [ :key |
    block value: key value: (self at: key)
  ]
  ^ self
]

# Native Table methods (defined in objects.nim):
# keys, includesKey:, removeKey:
# These are registered directly on the Table class

Table>>values [
  # Return array of all values.
  | result |
  result := Array new
  self keys do: [ :key | result add: (self at: key) ]
  ^ result
]

Table>>size [
  # Return number of key-value pairs.
  ^ self keys size
]

Table>>isEmpty [
  # Check if table has no entries.
  ^ self size = 0
]

Table>>notEmpty [
  # Check if table has entries.
  ^ self size > 0
]

Table>>keysAndValuesDo: block [
  # Iterate over all key-value pairs.
  self keys do: [ :key |
    block value: key value: (self at: key)
  ]
]

Table>>at: key ifAbsent: block [
  # Get value at key, or evaluate block if key not present.
  (self includesKey: key) ifTrue: [ ^ self at: key ] ifFalse: [ ^ block value ]
]

Table>>at: key ifAbsentPut: block [
  # Get value at key, or put result of block and return it.
  | value |
  (self includesKey: key) ifTrue: [ ^ self at: key ]
  value := block value
  self at: key put: value
  ^ value
]

Table>>at: key ifPresent: presentBlock [
  # If key present, evaluate presentBlock with value, else return nil.
  (self includesKey: key) ifTrue: [ ^ presentBlock value: (self at: key) ]
  ^ nil
]

Table>>at: key ifPresent: presentBlock ifAbsent: absentBlock [
  # If key present, evaluate presentBlock with value, else evaluate absentBlock.
  (self includesKey: key) ifTrue: [ ^ presentBlock value: (self at: key) ]
  ^ absentBlock value
]

#====================================================================
# Set (using Table as hash set)
# Note: Set class is created in Nim (objects.nim) with primitive implementations
#====================================================================

Set>>new <primitive primitiveSetNew>
  # Create new empty set

Set>>add: element <primitive primitiveSetAdd: element>
  # Add element to set

Set>>remove: element <primitive primitiveSetRemove: element>
  # Remove element from set

Set>>includes: element <primitive primitiveSetIncludes: element>
  # Check if set includes element

Set>>size <primitive primitiveSetSize>
  # Return number of elements

Set>>isEmpty [
  # Check if set is empty.
  ^ self size = 0
]

Set>>union: otherSet <primitive primitiveSetUnion: otherSet>
  # Return union of self and otherSet

Set>>intersection: otherSet <primitive primitiveSetIntersection: otherSet>
  # Return intersection of self and otherSet

Set>>difference: otherSet <primitive primitiveSetDifference: otherSet>
  # Return difference (self - otherSet)

Set>>do: block <primitive primitiveSetDo: block>
  # Iterate over all elements

#====================================================================
# Collection creation - class methods
Array>>sorted [
  # Return a new Array with elements sorted in ascending order.
  ^ self sorted: [ :a :b | a < b ]
]

Array>>sorted: sortBlock [
  # Return a new Array with elements sorted using the given sort block.
  # Uses simple insertion sort - good for small arrays.
  | result size i j key temp done |
  size := self size.
  result := Array new.

  # Copy all elements to result
  self do: [ :each | result add: each ].

  # Sort using insertion sort (positions 1 to size)
  i := 2.
  [ i <= size ] whileTrue: [
    j := i.
    key := result at: i.
    done := false.
    [ (j > 1) and: [ done not ] ] whileTrue: [
      temp := result at: (j - 1).
      (sortBlock value: key value: temp) ifTrue: [
        result at: j put: temp.
        j := j - 1
      ] ifFalse: [
        done := true
      ]
    ].
    result at: j put: key.
    i := i + 1
  ].

  ^ result
]

#====================================================================
# Collection creation - class methods
#====================================================================

Array>>new [
  # Create new empty array.
  ^ Array new: 0
]

# Note: Array new: and Table new are implemented as native class methods in objects.nim
# The primitives are registered directly on the classes
