#!/usr/bin/env harding
#
# Exception.nt - Exception handling for Harding
# Provides Smalltalk-style on:do: exception handling

#====================================================================
# Exception hierarchy
#====================================================================

Exception := Object derive: #(message stackTrace signaler)

Exception>>signal <primitive primitiveSignal>
  # Signal this exception (raise it)

Exception class>>signal: messageText [
  # Create a new instance, set the message, and signal the exception
  | ex |
  ex := self new.
  ex message: messageText.
  ^ ex signal
]

Exception>>signal: messageText [
  # Set message and signal this exception
  message := messageText
  ^ self signal
]

Exception>>return: value <primitive primitiveExceptionReturn: value>
  # Return value to the on:do: expression, unwinding the handler

Exception>>pass <primitive primitiveExceptionPass>
  # Delegate to the next outer matching handler

Exception>>retry <primitive primitiveExceptionRetry>
  # Re-execute the protected block

Exception>>isResumable [ ^ false ]

Exception>>resume <primitive primitiveExceptionResume>
  # Resume execution from signal point, returning nil from signal

Exception>>resume: value <primitive primitiveExceptionResume: value>
  # Resume execution from signal point, returning value from signal

Exception>>signalContext <primitive primitiveExceptionSignalContext>
  # Return the signal point context for debugging
  # This provides access to the full call stack at signal point

Exception>>signaler <primitive primitiveExceptionSignaler>
  # Return the object that signaled this exception
  # This is the receiver of the method that called signal

Exception>>signalActivationDepth <primitive primitiveExceptionSignalActivationDepth>
  # Return the activation stack depth at signal point
  # Useful for debugging and stack inspection

Exception>>message [
  # Get exception message
  ^ message
]

Exception>>message: msg [
  # Set exception message
  message := msg
]

Exception>>stackTrace [
  # Get stack trace
  ^ stackTrace
]

Exception>>printString [
  # String representation including message
  | msg |
  msg := message
  msg isNil ifTrue: [ msg := "Unknown error" ]
  ^ "Exception: " , msg
]

#====================================================================
# Common exception types
#====================================================================

Error := Exception derive

Notification := Exception derive

Notification>>isResumable [ ^ true ]

MessageNotUnderstood := Exception derive

SubscriptOutOfBounds := Exception derive

DivisionByZero := Exception derive

#====================================================================
# Block extension for exception handling
#====================================================================

Block>>on: exceptionClass do: handlerBlock <primitive primitiveOnDo: exceptionClass do: handlerBlock>
  # Execute this block with exception handler installed
  # Usage: [ protected code ] on: Error do: [ :ex | handler code ]

#====================================================================
# Error handling utilities
#====================================================================

Block>>ifError: errorBlock [
  # Execute this block, if error occurs run errorBlock with exception
  ^ self on: Error do: errorBlock
]

Block>>ifError: errorBlock ifNoError: normalBlock [
  # Execute this block, handle error or run normal block with result
  result := self on: Error do: [ :ex |
    ^ errorBlock value: ex
  ]
  ^ normalBlock value: result
]

#====================================================================
# Ensure (finally) support
#====================================================================

Block>>ensure: cleanupBlock [
  # Execute this block, always run cleanupBlock afterwards
  | result |
  # Note: This is a simplified version - full implementation needs primitive support
  result := self value
  cleanupBlock value
  ^ result
]
