#!/usr/bin/env harding
#
# Exception.nt - Exception handling for Harding
# Provides Smalltalk-style on:do: exception handling

#====================================================================
# Exception hierarchy
#====================================================================

Exception := Object derive: #(message stackTrace signaler)

Exception>>signal <primitive primitiveSignal>
  # Signal this exception (raise it)

Exception class>>signal: messageText [
  # Create a new instance, set the message, and signal the exception
  | ex |
  ex := self new.
  ex message: messageText.
  ^ ex signal
]

Exception>>signal: messageText [
  # Set message and signal this exception
  message := messageText
  ^ self signal
]

Exception>>message [
  # Get exception message
  ^ message
]

Exception>>message: msg [
  # Set exception message
  message := msg
]

Exception>>stackTrace [
  # Get stack trace
  ^ stackTrace
]

Exception>>printString [
  # String representation including message
  | msg |
  msg := message
  msg isNil ifTrue: [ msg := "Unknown error" ]
  ^ "Exception: " , msg
]

#====================================================================
# Common exception types
#====================================================================

Error := Exception derive

MessageNotUnderstood := Exception derive

SubscriptOutOfBounds := Exception derive

DivisionByZero := Exception derive

#====================================================================
# Block extension for exception handling
#====================================================================

Block>>on: exceptionClass do: handlerBlock <primitive primitiveOnDo: exceptionClass do: handlerBlock>
  # Execute this block with exception handler installed
  # Usage: [ protected code ] on: Error do: [ :ex | handler code ]

#====================================================================
# Error handling utilities
#====================================================================

Object>>ifError: errorBlock [
  # Execute self, if error occurs run errorBlock with exception
  ^ [ self ] on: Error do: errorBlock
]

Object>>ifError: errorBlock ifNoError: normalBlock [
  # Execute self, handle error or run normal block with result
  | result |
  result := [ self ] on: Error do: [ :ex |
    ^ errorBlock value: ex
  ]
  ^ normalBlock value: result
]

#====================================================================
# Ensure (finally) support
#====================================================================

Block>>ensure: cleanupBlock [
  # Execute this block, always run cleanupBlock afterwards
  | result |
  # Note: This is a simplified version - full implementation needs primitive support
  result := self value
  cleanupBlock value
  ^ result
]
