#!/usr/bin/env nemo
#
# Exception.nt - Exception handling for Nemo
# Provides Smalltalk-style on:do: exception handling

#====================================================================
# Exception hierarchy
#====================================================================

Exception := Object derive: #(message stackTrace signaler)

Exception>>signal [
  # Signal this exception (raise it)
  ^ self perform: #primitiveSignal
]

Exception>>signal: messageText [
  # Set message and signal this exception
  self at: "message" put: messageText
  ^ self signal
]

Exception>>message [
  # Get exception message
  ^ self getSlot: "message"
]

Exception>>message: msg [
  # Set exception message
  ^ self at: "message" put: msg
]

Exception>>stackTrace [
  # Get stack trace
  ^ self getSlot: "stackTrace"
]

Exception>>printString [
  # String representation including message
  | msg |
  msg := self getSlot: "message"
  msg isNil ifTrue: [ msg := "Unknown error" ]
  ^ "Exception: " , msg
]

#====================================================================
# Common exception types
#====================================================================

Error := Exception derive

MessageNotUnderstood := Exception derive

SubscriptOutOfBounds := Exception derive

DivisionByZero := Exception derive

#====================================================================
# Block extension for exception handling
#====================================================================

Block>>on: exceptionClass do: handlerBlock [
  # Execute this block with exception handler installed
  # Usage: [ protected code ] on: Error do: [ :ex | handler code ]
  ^ self perform: #primitiveOnDo: with: exceptionClass with: handlerBlock
]

#====================================================================
# Error handling utilities
#====================================================================

Object>>ifError: errorBlock [
  # Execute self, if error occurs run errorBlock with exception
  ^ [ self ] on: Error do: errorBlock
]

Object>>ifError: errorBlock ifNoError: normalBlock [
  # Execute self, handle error or run normal block with result
  | result |
  result := [ self ] on: Error do: [ :ex |
    ^ errorBlock value: ex
  ]
  ^ normalBlock value: result
]

#====================================================================
# Ensure (finally) support
#====================================================================

Block>>ensure: cleanupBlock [
  # Execute this block, always run cleanupBlock afterwards
  | result |
  # Note: This is a simplified version - full implementation needs primitive support
  result := self value
  cleanupBlock value
  ^ result
]
