# ============================================================================
# SortedCollection - A collection that maintains elements in sorted order
# Similar to Smalltalk's SortedCollection
# ============================================================================

SortedCollection := Array derive: #(sortBlock)

SortedCollection>>initialize [
  # Initialize with default sort block (ascending order)
  sortBlock := [ :a :b | a < b ]
]

SortedCollection>>sortBlock: aBlock [
  # Set the sort block and resort the collection
  sortBlock := aBlock.
  self resort
]

SortedCollection>>sortBlock [
  # Return the current sort block
  ^ sortBlock
]

SortedCollection>>add: anObject [
  # Add element in sorted position
  | index size |
  index := 1.
  size := self size.

  # Find insertion point
  [ index <= size ] whileTrue: [
    (sortBlock value: anObject value: (self at: index)) ifTrue: [
      # Insert here
      ^ self insert: anObject at: index
    ].
    index := index + 1
  ].

  # Add at end
  ^ super add: anObject
]

SortedCollection>>insert: anObject at: index [
  # Insert element at specific index (shifting existing elements)
  # This is an internal helper method
  | newArray i |
  newArray := Array new.

  # Copy elements before insertion point
  i := 1.
  [ i < index ] whileTrue: [
    newArray add: (self at: i).
    i := i + 1
  ].

  # Add new element
  newArray add: anObject.

  # Copy remaining elements
  [ i <= self size ] whileTrue: [
    newArray add: (self at: i).
    i := i + 1
  ].

  # Replace contents
  self removeAll.
  newArray do: [ :each | super add: each ].

  ^ anObject
]

SortedCollection>>resort [
  # Re-sort all elements using current sort block
  | sorted |
  sorted := self sorted: sortBlock.
  self removeAll.
  sorted do: [ :each | super add: each ]
]

SortedCollection>>reversed [
  # Return a new SortedCollection with reversed sort order
  | result |
  result := SortedCollection new.
  result sortBlock: [ :a :b | sortBlock value: b value: a ].
  self do: [ :each | result add: each ].
  ^ result
]

SortedCollection>>asSortedCollection [
  ^ self
]

SortedCollection>>asArray [
  # Return a plain Array with the same elements
  | result |
  result := Array new.
  self do: [ :each | result add: each ].
  ^ result
]

SortedCollection>>includes: anObject [
  # Check if object is in collection using binary search
  | low high mid |
  low := 1.
  high := self size.
  
  [ low <= high ] whileTrue: [
    mid := (low + high) // 2.
    (self at: mid) = anObject ifTrue: [ ^ true ].
    (sortBlock value: anObject value: (self at: mid))
      ifTrue: [ high := mid - 1 ]
      ifFalse: [ low := mid + 1 ]
  ].
  ^ false
]

# ============================================================================
# Class methods
# ============================================================================

SortedCollection class>>new [
  ^ self new: 0
]

SortedCollection class>>new: initialSize [
  | instance |
  instance := super new: initialSize.
  instance initialize.
  ^ instance
]

SortedCollection class>>sortBlock: aBlock [
  # Create a new SortedCollection with given sort block
  | instance |
  instance := self new.
  instance sortBlock: aBlock.
  ^ instance
]

SortedCollection class>>with: anArray [
  # Create a new SortedCollection from an array
  | instance |
  instance := self new.
  anArray do: [ :each | instance add: each ].
  ^ instance
]

SortedCollection class>>with: anArray sortBlock: aBlock [
  # Create a new SortedCollection from an array with custom sort block
  | instance |
  instance := self sortBlock: aBlock.
  anArray do: [ :each | instance add: each ].
  ^ instance
]
