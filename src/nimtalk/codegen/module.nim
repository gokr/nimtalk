import std/[strutils, tables, sequtils, os, strformat]
import ../core/types
import ../parser/parser
import ../parser/lexer
import ../compiler/context
import ../compiler/analyzer
import ../compiler/symbols
import ./slots
import ./methods
import ./control

# ============================================================================
# Module Generation
# Generates complete Nim modules from Nimtalk source
# ============================================================================

proc genModuleHeader*(ctx: var CompilerContext, moduleName: string): string =
  ## Generate module header with imports and documentation
  var output = ""

  output.add("## Generated by Nimtalk Compiler\n")
  output.add("## Module: " & moduleName & "\n")
  output.add("## Do not edit - generated from .nt source\n\n")

  output.add("# Imports\n")
  output.add("import std/[tables, sequtils]\n")
  output.add("import ../src/nimtalk/core/[types]\n")
  output.add("import ../src/nimtalk/interpreter/[objects, activation]\n\n")

  output.add("# Runtime imports\n")
  output.add("import ../src/nimtalk/runtime/[runtime]\n\n")

  return output

proc genPrototypeConstants*(proto: PrototypeInfo): string =
  ## Generate prototype constant declarations
  let protoName = manglePrototype(proto.name)

  var output = fmt("# {proto.name} Prototype\n")
  output.add("###################\n\n")

  # Slot count constant
  let slots = proto.getAllSlots()
  output.add(fmt("const {protoName}_slotCount* = {slots.len}\n"))

  # Slot name array
  if slots.len > 0:
    let slotNames = slots.mapIt(fmt("\"{it.name}\"")).join(", ")
    output.add(fmt("\nconst {protoName}_slotNames*: array[{slots.len}, string] = [\n"))
    output.add("  " & slotNames & "\n")
    output.add("]\n")

  # Method count
  output.add(fmt("\nconst {protoName}_methodCount = {proto.methods.len}\n"))

  output.add("\n")

  return output

proc genPrototypeInit*(proto: PrototypeInfo): string =
  ## Generate prototype initialization procedure
  let protoName = manglePrototype(proto.name)

  return fmt("""
proc init_{protoName}*(parent: ref ProtoObject = nil): ref ProtoObject {{.cdecl, exportc.}} =
  ## Initialize {proto.name} prototype
  ##
  var obj = if parent != nil:
              parent.clone()
            else:
              rootObject.clone()

  obj.tags.add("{proto.name}")

  # Initialize slots
  obj.slots.setLen({proto.getAllSlots().len()})

  # Register methods
  for meth in obj.methods.values:
    meth.nativeImpl = nil  # No native implementation yet

  return obj

""")

proc genModule*(ctx: var CompilerContext, nodes: seq[Node],
                moduleName: string): string =
  ## Generate complete Nim module from parsed nodes
  var output = ""

  output.add(genModuleHeader(ctx, moduleName))
  output.add(genRuntimeHelperMethods())
  output.add("\n")

  # Analyze prototypes
  let analysis = buildPrototypeGraph(nodes)

  # Resolve slot indices
  ctx.resolveSlotIndices()

  # Generate for each prototype
  for proto in analysis.prototypes.values:
    output.add(genPrototypeConstants(proto))
    output.add(genSlotAccessors(proto))
    output.add(genPrototypeInit(proto))

  # Generate control flow methods
  output.add("\n")
  output.add("# Control Flow Methods\n")
  output.add("######################\n\n")

  output.add(genWhileTrueMethod())
  output.add(genWhileFalseMethod())
  output.add(genIfTrueIfFalseMethod())
  output.add(genTimesRepeatMethod())

  # Generate binary operators
  output.add("\n")
  output.add("# Binary Operators\n")
  output.add("#################\n\n")

  for op in ["+", "-", "*", "/"]:
    output.add(genBinaryOpMethod(op))

  # Generate comparison operators
  output.add("\n")
  output.add("# Comparison Operators\n")
  output.add("#####################\n\n")

  for op in ["<", "<=", ">", ">=", "="]:
    output.add(genComparisonMethod(op))

  # Module initialization
  output.add("\n")
  output.add("# Module Initialization\n")
  output.add("######################\n")

  output.add(fmt("""
proc init_{moduleName}*() =
  ## Initialize {moduleName} module
  echo "Module loaded: {moduleName}"

when isMainModule:
  init_{moduleName}()
"""))

  return output

proc compileFile*(inputPath: string, outputDir = "./build"): string =
  ## Compile a Nimtalk source file to Nim
  let source = readFile(inputPath)
  let tokens = lex(source)
  var parser = initParser(tokens)
  let nodes = parser.parseStatements()

  if parser.hasError:
    echo "Parse error: " & parser.errorMsg
    return ""

  let moduleName = inputPath.extractFilename().changeFileExt("")

  var ctx = newCompiler(outputDir, moduleName)
  let nimCode = genModule(ctx, nodes, moduleName)

  let outputPath = outputDir / moduleName & ".nim"
  createDir(outputDir)
  writeFile(outputPath, nimCode)

  return outputPath
