import std/[strutils, tables, sequtils, os, strformat]
import ../core/types
import ../parser/parser
import ../parser/lexer
import ../compiler/context
import ../compiler/analyzer
import ../compiler/symbols
import ./slots
import ./methods
import ./control
import ./expression
import ./blocks

# ============================================================================
# Module Generation
# Generates complete Nim modules from Harding source
# ============================================================================

proc mangleModuleName*(name: string): string =
  ## Convert module name to valid Nim identifier
  ## Module names starting with digits are invalid in Nim, use -o flag to specify output name
  return name

proc genModuleHeader*(ctx: var CompilerContext, moduleName: string): string =
  ## Generate module header with imports and documentation
  var output = ""

  output.add("## Generated by Harding Compiler\n")
  output.add("## Module: " & moduleName & "\n")
  output.add("## Do not edit - generated from .hrd source\n\n")

  output.add("# Imports\n")
  output.add("import std/[tables, sequtils]\n")
  output.add("import ../src/harding/core/[types]\n")
  output.add("import ../src/harding/interpreter/[objects, activation]\n\n")

  output.add("# Runtime imports\n")
  output.add("import ../src/harding/runtime/[runtime]\n\n")

  return output

proc genClassConstants*(cls: ClassInfo): string =
  ## Generate class constant declarations
  let clsName = mangleClass(cls.name)

  var output = fmt("# {cls.name} Class\n")
  output.add("###################\n\n")

  # Slot count constant
  let slots = cls.getAllSlots()
  output.add(fmt("const {clsName}_slotCount* = {slots.len}\n"))

  # Slot name array
  if slots.len > 0:
    let slotNames = slots.mapIt(fmt("\"{it.name}\"")).join(", ")
    output.add(fmt("\nconst {clsName}_slotNames*: array[{slots.len}, string] = [\n"))
    output.add("  " & slotNames & "\n")
    output.add("]\n")

  # Method count
  output.add(fmt("\nconst {clsName}_methodCount = {cls.methods.len}\n"))

  output.add("\n")

  return output

proc genClassInit*(cls: ClassInfo): string =
  ## Generate class initialization procedure
  let clsName = mangleClass(cls.name)

  return fmt("""
proc init_{clsName}*(parent: ref RuntimeObject = nil): ref RuntimeObject {{.cdecl, exportc.}} =
  ## Initialize {cls.name} class
  ##
  var obj = if parent != nil:
              parent.clone()
            else:
              rootObject.clone()

  obj.tags.add("{cls.name}")

  # Initialize slots
  obj.slots.setLen({cls.getAllSlots().len()})

  # Register methods
  for meth in obj.methods.values:
    meth.nativeImpl = nil  # No native implementation yet

  return obj

""")

proc isClassDefinition(node: Node): bool =
  ## Check if a node is a class definition (derive: chain)
  if node.kind != nkMessage:
    return false
  let msg = node.MessageNode
  # Check for Class := Parent derive: ... pattern
  if msg.selector == "at:put:":
    if msg.arguments.len >= 2 and msg.arguments[1].kind == nkMessage:
      let valMsg = msg.arguments[1].MessageNode
      if valMsg.selector == "derive:" or valMsg.selector == "derive":
        return true
  return false

proc isMethodDefinition(node: Node): bool =
  ## Check if a node is a method definition (selector:put: or classSelector:put:)
  if node.kind != nkMessage:
    return false
  let msg = node.MessageNode
  return msg.selector in ["selector:put:", "classSelector:put:"]

proc extractClassAndMethodDefs(nodes: seq[Node]): tuple[defs: seq[Node], topLevel: seq[Node]] =
  ## Separate class/method definitions from top-level executable statements
  var defs: seq[Node] = @[]
  var topLevel: seq[Node] = @[]

  for node in nodes:
    if node.isClassDefinition or node.isMethodDefinition:
      defs.add(node)
    else:
      topLevel.add(node)

  return (defs, topLevel)

proc genMainProc*(ctx: var CompilerContext, topLevel: seq[Node], moduleName: string,
                  blockReg: BlockRegistry = nil): string =
  ## Generate the main() procedure for top-level statement execution
  var output = ""

  output.add("# Main Entry Point\n")
  output.add("##################\n\n")

  output.add("proc main(): int =\n")
  output.add("  ## Main entry point for ")
  output.add(moduleName)
  output.add("\n")

  # Initialize runtime
  output.add("  initRuntime()\n\n")

  # Create generation context for top-level code, sharing block registry if provided
  var genCtx = newGenContext(nil)
  if blockReg != nil:
    genCtx.blockRegistry = blockReg

  # Generate code for each top-level statement
  for node in topLevel:
    let stmtCode = genTopLevelStatement(genCtx, node)
    if stmtCode.len > 0:
      # Indent the statement
      for line in stmtCode.splitLines():
        output.add("  ")
        output.add(line)
        output.add("\n")

  # Return exit code 0
  output.add("\n  return 0\n")

  return output

proc genModule*(ctx: var CompilerContext, nodes: seq[Node],
                moduleName: string): string =
  ## Generate complete Nim module from parsed nodes
  var output = ""

  output.add(genModuleHeader(ctx, moduleName))
  output.add(genRuntimeHelperMethods())
  output.add("\n")
  output.add(genBlockRuntimeHelpers())
  output.add("\n")

  # Separate class/method definitions from top-level statements
  let (classDefs, topLevel) = extractClassAndMethodDefs(nodes)

  # Analyze classes
  let analysis = buildClassGraph(nodes)

  # Resolve slot indices
  ctx.resolveSlotIndices()

  # Generate for each class
  for cls in analysis.classes.values:
    output.add(genClassConstants(cls))
    output.add(genSlotAccessors(cls))
    output.add(genClassInit(cls))

  # Generate block procedure definitions
  output.add("\n")
  output.add("# Block Procedures\n")
  output.add("##################\n\n")

  # Create a block registry and collect blocks
  # Note: top-level variables are NOT passed as knownGlobals because they are
  # locals of main() and need to be captured by block procs at module level.
  # Only true globals (class names) would be excluded from captures.
  var blockReg = newBlockRegistry()
  for node in topLevel:
    collectBlocks(blockReg, node)

  # Generate environment structs for blocks with captures
  for blockInfo in blockReg.getAllBlocks():
    let structDef = generateEnvStructDef(blockInfo)
    if structDef.len > 0:
      output.add(structDef)
      output.add("\n\n")

  # Generate block procedure signatures and bodies using real code generation
  var blockGenCtx = newGenContext(nil)
  for blockInfo in blockReg.getAllBlocks():
    output.add(generateBlockProcSignature(blockInfo))
    output.add(" =\n")
    let body = genBlockBody(blockGenCtx, blockInfo.blockNode, blockInfo.captures,
                            blockInfo.hasNonLocalReturn)
    if body.len > 0:
      output.add(body)
    else:
      output.add("  return NodeValue(kind: vkNil)\n")
    output.add("\n\n")

  # Generate control flow methods
  output.add("\n")
  output.add("# Control Flow Methods\n")
  output.add("######################\n\n")

  output.add(genWhileTrueMethod())
  output.add(genWhileFalseMethod())
  output.add(genIfTrueIfFalseMethod())
  output.add(genTimesRepeatMethod())

  # Generate binary operators
  output.add("\n")
  output.add("# Binary Operators\n")
  output.add("#################\n\n")

  for op in ["+", "-", "*", "/"]:
    output.add(genBinaryOpMethod(op))

  # Generate comparison operators
  output.add("\n")
  output.add("# Comparison Operators\n")
  output.add("#####################\n\n")

  for op in ["<", "<=", ">", ">=", "=", "==", "~="]:
    output.add(genComparisonMethod(op))

  # Generate integer division and modulo operators
  output.add("\n")
  output.add("# Integer Division and Modulo\n")
  output.add("#############################\n\n")

  output.add(genBinaryOpMethod("//"))
  output.add(genBinaryOpMethod("\\"))
  output.add(genBinaryOpMethod("%"))

  # Generate main proc for top-level statements, sharing block registry
  output.add(genMainProc(ctx, topLevel, moduleName, blockReg))

  # Module initialization
  output.add("\n")
  output.add("# Module Initialization\n")
  output.add("######################\n")

  output.add(fmt("""
proc init_{moduleName}*() =
  ## Initialize {moduleName} module
  initRuntime()
  echo "Module loaded: {moduleName}"

when isMainModule:
  discard main()
"""))

  return output

proc compileFile*(inputPath: string, outputDir = "./build"): string =
  ## Compile a Harding source file to Nim
  let source = readFile(inputPath)
  let tokens = lex(source)
  var parser = initParser(tokens)
  let nodes = parser.parseStatements()

  if parser.hasError:
    echo "Parse error: " & parser.errorMsg
    return ""

  let moduleName = inputPath.extractFilename().changeFileExt("")

  var ctx = newCompiler(outputDir, moduleName)
  let nimCode = genModule(ctx, nodes, moduleName)

  let outputPath = outputDir / moduleName & ".nim"
  createDir(outputDir)
  writeFile(outputPath, nimCode)

  return outputPath
