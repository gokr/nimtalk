import std/[strutils, tables, sequtils, os, strformat]
import ../core/types
import ../parser/parser
import ../parser/lexer
import ../compiler/context
import ../compiler/analyzer
import ../compiler/symbols
import ./slots
import ./methods
import ./control

# ============================================================================
# Module Generation
# Generates complete Nim modules from Nemo source
# ============================================================================

proc genModuleHeader*(ctx: var CompilerContext, moduleName: string): string =
  ## Generate module header with imports and documentation
  var output = ""

  output.add("## Generated by Nemo Compiler\n")
  output.add("## Module: " & moduleName & "\n")
  output.add("## Do not edit - generated from .nt source\n\n")

  output.add("# Imports\n")
  output.add("import std/[tables, sequtils]\n")
  output.add("import ../src/nemo/core/[types]\n")
  output.add("import ../src/nemo/interpreter/[objects, activation]\n\n")

  output.add("# Runtime imports\n")
  output.add("import ../src/nemo/runtime/[runtime]\n\n")

  return output

proc genClassConstants*(cls: ClassInfo): string =
  ## Generate class constant declarations
  let clsName = mangleClass(cls.name)

  var output = fmt("# {cls.name} Class\n")
  output.add("###################\n\n")

  # Slot count constant
  let slots = cls.getAllSlots()
  output.add(fmt("const {clsName}_slotCount* = {slots.len}\n"))

  # Slot name array
  if slots.len > 0:
    let slotNames = slots.mapIt(fmt("\"{it.name}\"")).join(", ")
    output.add(fmt("\nconst {clsName}_slotNames*: array[{slots.len}, string] = [\n"))
    output.add("  " & slotNames & "\n")
    output.add("]\n")

  # Method count
  output.add(fmt("\nconst {clsName}_methodCount = {cls.methods.len}\n"))

  output.add("\n")

  return output

proc genClassInit*(cls: ClassInfo): string =
  ## Generate class initialization procedure
  let clsName = mangleClass(cls.name)

  return fmt("""
proc init_{clsName}*(parent: ref RuntimeObject = nil): ref RuntimeObject {{.cdecl, exportc.}} =
  ## Initialize {cls.name} class
  ##
  var obj = if parent != nil:
              parent.clone()
            else:
              rootObject.clone()

  obj.tags.add("{cls.name}")

  # Initialize slots
  obj.slots.setLen({cls.getAllSlots().len()})

  # Register methods
  for meth in obj.methods.values:
    meth.nativeImpl = nil  # No native implementation yet

  return obj

""")

proc genModule*(ctx: var CompilerContext, nodes: seq[Node],
                moduleName: string): string =
  ## Generate complete Nim module from parsed nodes
  var output = ""

  output.add(genModuleHeader(ctx, moduleName))
  output.add(genRuntimeHelperMethods())
  output.add("\n")

  # Analyze classes
  let analysis = buildClassGraph(nodes)

  # Resolve slot indices
  ctx.resolveSlotIndices()

  # Generate for each class
  for cls in analysis.classes.values:
    output.add(genClassConstants(cls))
    output.add(genSlotAccessors(cls))
    output.add(genClassInit(cls))

  # Generate control flow methods
  output.add("\n")
  output.add("# Control Flow Methods\n")
  output.add("######################\n\n")

  output.add(genWhileTrueMethod())
  output.add(genWhileFalseMethod())
  output.add(genIfTrueIfFalseMethod())
  output.add(genTimesRepeatMethod())

  # Generate binary operators
  output.add("\n")
  output.add("# Binary Operators\n")
  output.add("#################\n\n")

  for op in ["+", "-", "*", "/"]:
    output.add(genBinaryOpMethod(op))

  # Generate comparison operators
  output.add("\n")
  output.add("# Comparison Operators\n")
  output.add("#####################\n\n")

  for op in ["<", "<=", ">", ">=", "="]:
    output.add(genComparisonMethod(op))

  # Module initialization
  output.add("\n")
  output.add("# Module Initialization\n")
  output.add("######################\n")

  output.add(fmt("""
proc init_{moduleName}*() =
  ## Initialize {moduleName} module
  echo "Module loaded: {moduleName}"

when isMainModule:
  init_{moduleName}()
"""))

  return output

proc compileFile*(inputPath: string, outputDir = "./build"): string =
  ## Compile a Nemo source file to Nim
  let source = readFile(inputPath)
  let tokens = lex(source)
  var parser = initParser(tokens)
  let nodes = parser.parseStatements()

  if parser.hasError:
    echo "Parse error: " & parser.errorMsg
    return ""

  let moduleName = inputPath.extractFilename().changeFileExt("")

  var ctx = newCompiler(outputDir, moduleName)
  let nimCode = genModule(ctx, nodes, moduleName)

  let outputPath = outputDir / moduleName & ".nim"
  createDir(outputDir)
  writeFile(outputPath, nimCode)

  return outputPath
