import std/[strutils, tables, sequtils, os]
import ../core/types
import ../parser/parser
import ../parser/lexer
import ./context
import ./symbols
import ./types

# ============================================================================
# Nim Compiler for Nemo
# Generates Nim code from Smalltalk methods
# ============================================================================

# Re-export for convenience
export context.CompilerContext, context.newCompiler
export symbols.mangleSelector

# Generate method stub
proc genMethodStub(meth: BlockNode, selector: string): string =
  ## Generate Nim procedure stub for a Smalltalk method
  let nimName = mangleSelector(selector)
  let arity = meth.parameters.len

  var output = "proc " & nimName & "*(self: ref RuntimeObject"

  # Add parameters
  for param in meth.parameters:
    output.add(", " & param & ": NodeValue")

  output.add("): NodeValue {.cdecl, exportc.} =\n")
  output.add("  ## Compiled method: " & selector & "\n")
  output.add("  ##\n")
  output.add("  discard\n")
  output.add("  return self.toValue()\n\n")

  return output

# Generate entire module
proc compileModule*(ctx: CompilerContext, methods: seq[BlockNode],
                   moduleName: string): string =
  ## Compile a set of methods to a Nim module
  if methods.len == 0:
    return ""

  var output = "## Generated by Nemo Compiler\n"
  output.add("## Module: " & moduleName & "\n\n")
  output.add("import ../../src/nemo/core/[types]\n")
  output.add("import ../../src/nemo/interpreter/[objects, activation]\n\n")

  # Track methods
  ctx.methods = methods

  # Generate method stubs
  for meth in methods:
    # Extract selector from method (for now, use a dummy)
    let selector = if meth.parameters.len > 0:
                     "method" & $meth.parameters.len
                   else:
                     "method"
    ctx.symbols[selector] = mangleSelector(selector)
    output.add(genMethodStub(meth, selector))

  # Add module initialization
  output.add("proc init_" & moduleName & "*() =\n")
  output.add("  ## Initialize compiled module\n")
  output.add("  echo \"Module loaded: " & moduleName & "\"\n\n")

  return output

# Write module to file
proc writeModule*(ctx: CompilerContext, nimCode: string,
                 moduleName: string): string =
  ## Write compiled Nim code to file
  let filename = ctx.outputDir / moduleName & ".nim"
  createDir(ctx.outputDir)
  writeFile(filename, nimCode)
  return filename

# Simple compilation test
proc testCompilation*(): bool =
  ## Test basic compilation
  echo "Testing compilation..."

  try:
    let ctx = newCompiler()

    # Create a simple method
    let source = "[ :x | x ]"
    let tokens = lex(source)
    var parser = initParser(tokens)
    let meth = parser.parseBlock()

    if meth == nil:
      echo "Failed to parse block"
      return false

    meth.isMethod = true
    meth.parameters = @["x"]

    # Compile it
    let code = compileModule(ctx, @[meth], "test")
    if code.len > 0:
      echo "Generated code length: " & $code.len
      discard writeModule(ctx, code, "test")
      echo "Compilation test passed"
      return true
    else:
      echo "No code generated"
      return false
  except Exception as e:
    echo "Compilation test failed: " & e.msg
    return false

when isMainModule:
  let ok = testCompilation()
  quit(if ok: 0 else: 1)
